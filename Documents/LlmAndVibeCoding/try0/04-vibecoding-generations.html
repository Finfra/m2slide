<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4. 바이브 코딩 세대 구분 - Markmap</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    }
    .header {
      background: #2c3e50;
      color: white;
      padding: 1rem 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .header h1 {
      margin: 0;
      font-size: 1.5rem;
    }
    .header a {
      color: #3498db;
      text-decoration: none;
      font-size: 0.9rem;
    }
    .header a:hover {
      text-decoration: underline;
    }
    .markmap {
      position: relative;
      width: 100%;
      height: calc(100vh - 80px);
    }
    .markmap > svg {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>4. 바이브 코딩 세대 구분</h1>
    <a href="index.html">← 목차로 돌아가기</a>
  </div>

  <div class="markmap">
    <script type="text/template">
# 4. 바이브 코딩 세대 구분

## 세대 구분의 기준

바이브 코딩 도구는 **실행 환경**과 **작업 방식**에 따라 크게 두 세대로 구분됩니다.

```
1세대: IDE 기반          2세대: CLI 기반
(GUI 중심)               (터미널 중심)
```

---

## 4.1 1세대: IDE 기반 코딩

### 개념

**IDE(통합 개발 환경) 내부**에서 AI와 협업하는 방식입니다. 친숙한 GUI 환경에서 시각적으로 AI와 상호작용합니다.

### 대표 툴

**Cursor**
- VSCode 포크 기반 AI 네이티브 IDE
- GPT-4 기반 코드 생성 및 편집
- Composer 모드로 멀티파일 작업

**Cline (구 Claude Dev)**
- VSCode 확장 프로그램
- 다양한 LLM 모델 선택 가능
- 채팅 인터페이스 기반

**Windsurf**
- Codeium 개발
- Cascade 모드로 자율 작업
- 컨텍스트 인식 코드 생성

**Continue**
- VSCode/JetBrains 확장
- 로컬 모델 연동 가능
- 실시간 코드 편집

### 특징

**장점**

✅ **직관적인 GUI**
- 시각적 인터페이스로 진입 장벽 낮음
- 마우스 클릭으로 쉽게 작업
- 코드 변경 사항을 diff 모드로 확인

✅ **IDE 기능 활용**
- 디버거, 터미널, Git 통합
- 익숙한 단축키 사용
- 파일 탐색기 활용

✅ **실시간 피드백**
- 코드 작성 중 즉시 제안
- 인라인 자동완성
- 오류 즉시 확인

**단점**

❌ **로컬 리소스 의존**
- IDE 실행으로 메모리 8GB+ 필요
- CPU 사용량 높음
- 배터리 소모 증가

❌ **단일 프로젝트 제한**
- 한 번에 하나의 프로젝트만 집중
- 멀티 프로젝트 작업 시 IDE 여러 개 실행 필요

❌ **GUI 오버헤드**
- 그래픽 렌더링으로 인한 성능 저하
- 원격 서버 작업 시 불편

### 작동 방식

```
1. IDE 실행
   ↓
2. AI 확장/기능 활성화
   ↓
3. 채팅 패널에서 요청
   ↓
4. AI가 코드 생성/수정
   ↓
5. diff 모드로 확인
   ↓
6. 승인 또는 거부
```

### 적합한 사용자

- **초보 개발자**: GUI 환경이 익숙한 사용자
- **프론트엔드 개발자**: 시각적 피드백이 중요한 작업
- **단일 프로젝트 집중**: 하나의 프로젝트에 깊이 파고드는 경우
- **윈도우/맥 사용자**: 로컬 환경 개발 선호

### 대표적인 워크플로우

**Cursor Composer 예시**

```
1. Cmd+K (macOS) / Ctrl+K (Windows) 단축키
2. "사용자 프로필 페이지 만들어줘" 입력
3. AI가 필요한 파일들을 자동으로 생성/수정
   - UserProfile.tsx
   - UserProfile.css
   - types/User.ts
4. 각 파일의 변경사항을 diff로 확인
5. Accept All 또는 개별 승인
6. 실행 및 테스트
```

---

## 4.2 2세대: CLI 기반 코딩

### 개념

**터미널(CLI)** 에서 AI와 대화하며 작업하는 방식입니다. IDE 없이도 프로젝트 전체를 자동화할 수 있습니다.

### 대표 툴

**Claude Code**
- Anthropic 공식 CLI 도구
- 터미널에서 Claude와 직접 대화
- 프로젝트 전체 컨텍스트 이해
- 자동 파일 수정 및 명령 실행

**Gemini CLI**
- Google Gemini 기반
- 빠른 응답 속도
- 클라우드 기반 실행
- DevOps 작업에 최적화

**Aider**
- Git 친화적 AI 코딩 도구
- 터미널 기반 페어 프로그래밍
- 자동 커밋 메시지 생성

### 특징

**장점**

✅ **서버/클라우드 기반**
- 로컬 리소스 거의 사용 안 함
- 노트북 배터리 절약
- 원격 서버에서 작업 가능

✅ **무제한 병렬 처리**
- 여러 터미널에서 동시 작업
- 멀티 프로젝트 동시 관리
- 백그라운드 실행 가능

✅ **스크립트 자동화**
- 쉘 스크립트와 결합
- CI/CD 파이프라인 통합
- DevOps 워크플로우 자동화

✅ **빠른 실행 속도**
- GUI 오버헤드 없음
- 텍스트 기반으로 빠른 응답
- 네트워크 대역폭 효율적

**단점**

❌ **학습 곡선**
- 터미널 명령어 숙지 필요
- GUI 없이 작업해야 함
- 코드 변경 사항 시각화 제한적

❌ **시각적 피드백 부족**
- diff 확인이 텍스트 기반
- 그래픽 UI 프리뷰 불가

❌ **초기 설정**
- 환경 변수 설정 필요
- API 키 설정 필수

### 작동 방식

```bash
# Claude Code 예시
$ claude-code

> 프로젝트 분석해서 README.md 업데이트해줘

[Claude가 프로젝트 파일들을 읽고 분석]
[README.md 자동 수정]
[변경사항 표시]

> 테스트 코드도 작성해줘

[테스트 파일 자동 생성]
[npm test 실행하여 검증]
```

### 적합한 사용자

- **시니어 개발자**: 터미널에 익숙한 사용자
- **백엔드/DevOps 개발자**: 서버 관리 및 자동화 작업
- **멀티 프로젝트 관리**: 여러 프로젝트를 동시에 진행
- **리눅스 사용자**: CLI 환경 선호
- **원격 개발**: SSH로 원격 서버 작업

### 대표적인 워크플로우

**Claude Code 예시**

```bash
# 프로젝트 디렉토리에서
$ claude-code

> AWS Lambda 함수로 이미지 리사이징 서비스 만들어줘.
  S3에서 이미지 받아서 처리하고 다시 S3에 저장.

[Claude가 작업 시작]
✓ lambda_function.py 생성
✓ requirements.txt 생성
✓ 환경변수 설정 확인
✓ SAM template 생성
✓ README.md 업데이트

> 로컬에서 테스트해줘

[sam local invoke 실행]
[테스트 결과 확인]

> 문제없으면 배포해줘

[sam deploy 실행]
[배포 완료]
```

---

## 세대별 핵심 차이

| 구분 | 1세대 (IDE) | 2세대 (CLI) |
|------|------------|------------|
| **실행 환경** | IDE 내부 | 터미널 |
| **인터페이스** | GUI | CLI |
| **메모리 사용** | 높음 (8GB+) | 낮음 (<1GB) |
| **병렬 작업** | 제한적 | 무제한 |
| **실행 위치** | 로컬 | 서버/클라우드 |
| **자동화** | 제한적 | 완전 자동화 |
| **DevOps** | 부분 지원 | 완전 지원 |
| **학습 난이도** | 쉬움 | 중간 |
| **진입 장벽** | 낮음 | 중간 |

---

## 하이브리드 활용

두 세대를 함께 사용하는 전략:

### 시나리오별 선택

**프론트엔드 개발**
- 1세대 (Cursor): UI 컴포넌트 작성 및 스타일링
- 2세대 (Claude Code): 빌드 설정 및 배포 자동화

**풀스택 개발**
- 1세대 (Cline): 프론트엔드와 API 개발
- 2세대 (Gemini CLI): 인프라 구성 및 CI/CD

**DevOps/인프라**
- 2세대 주력: Terraform, Ansible 코드 생성
- 1세대 보조: 스크립트 디버깅 시 시각적 확인

### 팀 협업

**주니어 개발자**
- 1세대로 시작하여 기본 익히기
- 점진적으로 2세대 도입

**시니어 개발자**
- 2세대로 생산성 극대화
- 주니어 지도 시 1세대 활용

---

## 선택 가이드

### 1세대를 선택해야 할 때

- 처음 바이브 코딩 시작하는 경우
- GUI 환경이 익숙한 경우
- 프론트엔드 개발 중심
- 시각적 피드백이 중요한 작업
- 로컬 환경에서만 작업

### 2세대를 선택해야 할 때

- 터미널 작업이 익숙한 경우
- 여러 프로젝트 동시 관리
- DevOps/인프라 자동화
- 원격 서버 작업
- 스크립트 자동화 필요
- 로컬 리소스 절약 필요

### 두 가지 모두 사용

- 풀스택 개발자
- 대규모 프로젝트
- 팀 협업 환경
- 다양한 워크플로우

    </script>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/markmap-autoloader@latest"></script>
</body>
</html>
